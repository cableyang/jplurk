#summary version 1.1

= JPkurk 1.1 簡介 =

JPlurk 1.1 版是開發中的版本，以 1.0 版為基礎在架構上增加可擴充的設計。
我們將 JPlurk 的實作區分為：

  * 網路溝通的底層 (一般來說，開發者也不會修改到它)
  * Plurk 操作行為 (開發者能擴充新的操作行為)
  * Plurk 代理人 (能加上提供一般使用者使用的行為)

對使用者來說，它只需要會使用 Plurk 代理人即可：

{{{
// 透過 jvm 動態參數建立 Account 物件
// 例如：-Dplurk.user=your_account -Dplurk.passwd=your_passwd
IPlurkAgent agent = new PlurkAgent(Account.createWithDynamicProperties());

// 執行登入
agent.login();

// 顯示未讀取的 plurk
Result result = agent.getUnreadPlurks();
}}}

對開發著來說，它必需實作 Plurk 操作行為，並擴充至 IPlurkAgent 內。每個操作行為必需實作 com.googlecode.jplurk.behavior.IBehavior：
{{{
public interface IBehavior {
	public boolean action(final Request params, Object arg);
}
}}}

Request 參數是用來執行 Http Request 使用的參數，基本上它內含 Map 物件存放實際的參數。除此之外，它還有 EndPoint 與 User UID 欄位，是發送請求實必填的。但開發者只需要填入 EndPoint 即可，因為 User UID 欄位的內容會在使用者執行 Login 後獲得，並在發送 Request 前自動填上。

以 com.googlecode.jplurk.behavior.GetUnreadPlurks 為例，要取得未讀取 Plurk 的 EndPoint 為 (/TimeLine/getUnreadPlurks 已定義在 Constants.GET_UNREAD_PLURK_URL)，它的實作如下：
{{{
public class GetUnreadPlurks implements IBehavior{

	@Override
	public boolean action(Request params, Object arg) {
		params.setEndPoint(Constants.GET_UNREAD_PLURK_URL);
		params.addParam("fetch_responses", "false");
		return true;
	}

}
}}}

對任何的 IBehavior 來說，它會以下列的方式執行：
{{{
protected Result execute(Class<? extends IBehavior> clazz, Object args){
	if(!isLogin) {
		throw new NotLoginException();
	}

	Result result = plurkTemplate.doAction(clazz, args);

	if(!result.isOk()){
		throw new RequestFailureException();
	}
	return result;
}
}}}

由 IBehavior 執行的實作，開發者須注意：

  * 所有的 IBehavior 必需在登入的狀態執行 (即為獲得合法的 User UID 後。)
  * IBehavior 是執行時才動態建立的。因為，我們希望它是無狀態的，在設計上利用建立的方式作為限制的手段。